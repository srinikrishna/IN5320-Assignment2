/* eslint-disable */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var propTypes = _interopDefault(require('@dhis2/prop-types'));
var uiWidgets = require('@dhis2/ui-widgets');
var i18n = _interopDefault(require('@dhis2/d2-i18n'));
var uiCore = require('@dhis2/ui-core');
var reactFinalForm = require('react-final-form');
var finalForm = require('final-form');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const createBlurHandler = (input, onBlur) => (payload, event) => {
  input.onBlur(event);

  if (onBlur && typeof onBlur === 'function') {
    onBlur(payload, event);
  }
};

const PRIMITIVE_TYPES = new Set(['string', 'number', 'boolean']);

const createChangeHandler = ({
  onChange
}) => payload => {
  if (payload && 'value' in payload) {
    // ui-core event signature
    onChange(payload.value);
  } else if (payload && payload.target && 'value' in payload.target) {
    // synthetic event
    onChange(payload.target.value);
  } else if (PRIMITIVE_TYPES.has(typeof payload)) {
    // directly usable value
    onChange(payload);
  } else {
    // ¯\_(ツ)_/¯
    throw new Error('Could not process event payload');
  }
};

const createFocusHandler = (input, onFocus) => (payload, event) => {
  input.onFocus(event);

  if (onFocus && typeof onFocus === 'function') {
    onFocus(payload, event);
  }
};

const createSelectChangeHandler = ({
  onChange
}) => ({
  selected
}) => {
  onChange(selected);
};

const createToggleChangeHandler = (input, onChange) => (payload, event) => {
  input.onChange(event);

  if (onChange && typeof onChange === 'function') {
    onChange(payload, event);
  }
};

const hasError = (meta, error) => error || meta.touched && meta.invalid;

const getValidationText = (meta, validationText, error) => {
  if (validationText) {
    return validationText;
  }

  if (hasError(meta, error)) {
    if (meta.error) {
      return meta.error;
    }

    if (meta.submitError) {
      return meta.submitError;
    }
  }

  return '';
};

const isLoading = (meta, loading, showLoadingStatus) => loading || showLoadingStatus && meta.validating;

const isValid = (meta, valid, showValidStatus) => valid || showValidStatus && meta.touched && meta.valid;

const toggleGroupOptionsProp = propTypes.arrayOf(propTypes.shape({
  label: propTypes.string.isRequired,
  value: propTypes.string.isRequired
}));
const inputPropType = propTypes.shape({
  name: propTypes.string.isRequired,
  onChange: propTypes.func.isRequired,
  value: propTypes.any,
  onBlur: propTypes.func,
  onFocus: propTypes.func
});
const metaPropType = propTypes.shape({
  error: propTypes.string,
  invalid: propTypes.bool,
  touched: propTypes.bool,
  valid: propTypes.bool,
  validating: propTypes.bool
});

const CheckboxFieldFF = (_ref) => {
  let {
    error,
    input,
    meta,
    showValidStatus,
    valid,
    validationText,
    onBlur,
    onFocus
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["error", "input", "meta", "showValidStatus", "valid", "validationText", "onBlur", "onFocus"]);

  return /*#__PURE__*/React.createElement(uiWidgets.CheckboxField, _extends({}, rest, {
    name: input.name,
    checked: input.checked,
    value: input.value,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createToggleChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur)
  }));
};
CheckboxFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  error: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const btnLabel = i18n.t('Upload file');
const btnLabelMulti = i18n.t('Upload files');

const dedupeAndConcat = (currentFiles, newFileList) => {
  return [...currentFiles, ...newFileList].reduceRight((acc, file) => {
    if (!acc.unique.has(file.name)) {
      acc.unique.add(file.name);
      acc.files.unshift(file);
    }

    return acc;
  }, {
    files: [],
    unique: new Set()
  }).files;
};

const createChangeHandler$1 = (input, multifile) => ({
  files
}) => {
  // A JavaScript FileList instance is read-only, so we cannot add files to it
  // FileList also doesn't have a .map method so by destructuring the FileList
  // instance into an array we can add, remove and map
  const currentFiles = Array.isArray(input.value) ? input.value : [];
  const value = multifile ? dedupeAndConcat(currentFiles, files) : [...files];
  input.onChange(value);
};

const createRemoveHandler = (input, fileToDelete) => () => {
  const files = input.value.filter(file => file !== fileToDelete);
  const value = files.length > 0 ? files : '';
  input.onChange(value);
};

const FileInputFieldFF = (_ref) => {
  let {
    buttonLabel,
    disabled,
    error,
    input,
    meta,
    multifile,
    showValidStatus,
    valid,
    validationText
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["buttonLabel", "disabled", "error", "input", "meta", "multifile", "showValidStatus", "valid", "validationText"]);

  const files = input.value || [];
  return /*#__PURE__*/React.createElement(uiWidgets.FileInputField, _extends({}, rest, {
    onChange: createChangeHandler$1(input, multifile),
    buttonLabel: buttonLabel || multifile ? btnLabelMulti : btnLabel,
    disabled: disabled || !multifile && files.length >= 1,
    multiple: multifile,
    name: input.name,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    validationText: getValidationText(meta, validationText, error)
  }), files.map(file => /*#__PURE__*/React.createElement(uiCore.FileListItem, {
    key: file.name,
    label: file.name,
    onRemove: createRemoveHandler(input, file),
    removeText: i18n.t('Remove')
  })));
};
FileInputFieldFF.defaultProps = {
  placeholder: i18n.t('No file(s) selected yet')
};
FileInputFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  buttonLabel: propTypes.string,
  disabled: propTypes.bool,
  error: propTypes.bool,
  multifile: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  value: propTypes.oneOfType([propTypes.arrayOf(propTypes.instanceOf(File)), propTypes.oneOf([''])])
};

const InputFieldFF = (_ref) => {
  let {
    input,
    meta,
    error,
    showValidStatus,
    valid,
    validationText,
    onBlur,
    onFocus,
    loading,
    showLoadingStatus
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["input", "meta", "error", "showValidStatus", "valid", "validationText", "onBlur", "onFocus", "loading", "showLoadingStatus"]);

  return /*#__PURE__*/React.createElement(uiWidgets.InputField, _extends({}, rest, {
    name: input.name,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    loading: isLoading(meta, loading, showLoadingStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur),
    value: input.value
  }));
};
InputFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  error: propTypes.bool,
  loading: propTypes.bool,
  showLoadingStatus: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const MultiSelectFieldFF = (_ref) => {
  let {
    error,
    input,
    loading,
    meta,
    onBlur,
    onFocus,
    options,
    showLoadingStatus,
    showValidStatus,
    valid,
    validationText
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["error", "input", "loading", "meta", "onBlur", "onFocus", "options", "showLoadingStatus", "showValidStatus", "valid", "validationText"]);

  return /*#__PURE__*/React.createElement(uiWidgets.MultiSelectField, _extends({}, rest, {
    name: input.name,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    loading: isLoading(meta, loading, showLoadingStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createSelectChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur),
    selected: input.value || []
    /* input.value is an empty string initially, so we're providing an empty array if falsey */

  }), options.map(option => /*#__PURE__*/React.createElement(uiCore.MultiSelectOption, _extends({
    key: option.value
  }, option))));
};
MultiSelectFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  error: propTypes.bool,
  loading: propTypes.bool,
  options: propTypes.arrayOf(propTypes.shape({
    label: propTypes.string,
    value: propTypes.string
  })),
  showLoadingStatus: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const SingleSelectFieldFF = (_ref) => {
  let {
    error,
    input,
    loading,
    meta,
    onBlur,
    onFocus,
    options,
    showLoadingStatus,
    showValidStatus,
    valid,
    validationText
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["error", "input", "loading", "meta", "onBlur", "onFocus", "options", "showLoadingStatus", "showValidStatus", "valid", "validationText"]);

  return /*#__PURE__*/React.createElement(uiWidgets.SingleSelectField, _extends({}, rest, {
    name: input.name,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    loading: isLoading(meta, loading, showLoadingStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createSelectChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur),
    selected: input.value || ''
  }), options.map(option => /*#__PURE__*/React.createElement(uiCore.SingleSelectOption, _extends({
    key: option.value
  }, option))));
};
SingleSelectFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  options: propTypes.arrayOf(propTypes.shape({
    label: propTypes.string,
    value: propTypes.string
  })).isRequired,
  error: propTypes.bool,
  loading: propTypes.bool,
  showLoadingStatus: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const RadioFieldFF = (_ref) => {
  let {
    error,
    input,
    meta,
    showValidStatus,
    valid,
    validationText,
    onBlur,
    onFocus
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["error", "input", "meta", "showValidStatus", "valid", "validationText", "onBlur", "onFocus"]);

  return /*#__PURE__*/React.createElement(uiCore.Radio, _extends({}, rest, {
    name: input.name,
    checked: input.checked,
    value: input.value,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createToggleChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur)
  }));
};
RadioFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  error: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const SwitchFieldFF = (_ref) => {
  let {
    error,
    input,
    meta,
    showValidStatus,
    valid,
    validationText,
    onBlur,
    onFocus
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["error", "input", "meta", "showValidStatus", "valid", "validationText", "onBlur", "onFocus"]);

  return /*#__PURE__*/React.createElement(uiWidgets.SwitchField, _extends({}, rest, {
    checked: input.checked,
    name: input.name,
    value: input.value,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createToggleChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur)
  }));
};
SwitchFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  error: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const TextAreaFieldFF = (_ref) => {
  let {
    input,
    meta,
    error,
    showValidStatus,
    valid,
    validationText,
    onBlur,
    onFocus,
    loading,
    showLoadingStatus
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["input", "meta", "error", "showValidStatus", "valid", "validationText", "onBlur", "onFocus", "loading", "showLoadingStatus"]);

  return /*#__PURE__*/React.createElement(uiWidgets.TextAreaField, _extends({}, rest, {
    name: input.name,
    error: hasError(meta, error),
    valid: isValid(meta, valid, showValidStatus),
    loading: isLoading(meta, loading, showLoadingStatus),
    validationText: getValidationText(meta, validationText, error),
    onFocus: createFocusHandler(input, onFocus),
    onChange: createChangeHandler(input),
    onBlur: createBlurHandler(input, onBlur),
    value: input.value
  }));
};
TextAreaFieldFF.propTypes = {
  input: inputPropType.isRequired,
  meta: metaPropType.isRequired,
  error: propTypes.bool,
  loading: propTypes.bool,
  showLoadingStatus: propTypes.bool,
  showValidStatus: propTypes.bool,
  valid: propTypes.bool,
  validationText: propTypes.string,
  onBlur: propTypes.func,
  onFocus: propTypes.func
};

const FieldGroupFF = ({
  name,
  label,
  children,
  required
}) => {
  const {
    meta: {
      error,
      touched
    }
  } = reactFinalForm.useField(name, {
    subscription: {
      error: true,
      touched: true
    }
  });
  const isError = !!error && !!touched;
  let errorText;

  if (isError) {
    if (typeof error === 'string') {
      errorText = error;
    } else if (typeof error === 'object' && error[name]) {
      errorText = error[name];
    } else {
      errorText = null;
    }
  }

  return /*#__PURE__*/React.createElement(uiWidgets.FieldGroup, {
    label: label,
    required: required,
    error: isError,
    name: name,
    validationText: errorText
  }, children);
};
FieldGroupFF.propTypes = {
  children: propTypes.node,
  label: propTypes.string,
  name: propTypes.string,
  required: propTypes.bool
};

const format = value => !value ? [] : value.map(({
  id
}) => id);

const parse = value => !value || Array.isArray(value) && value.length === 0 ? undefined : value.map(id => ({
  id
}));

const arrayWithIdObjects = {
  format,
  parse
};

const isEmpty = value => typeof value === 'undefined' || value === null || value === '';
const isString = value => typeof value === 'string';
const isInteger = value => Number.isSafeInteger(value);
const isNumber = value => typeof value === 'number';
const isNumeric = value => (isString(value) || isNumber(value)) && !isNaN(value);
const isInRange = (lowerBound, upperBound, value) => value >= lowerBound && value <= upperBound;
const toNumber = value => Number(value);
const requiredArgumentErrorMessage = 'Incorrect arguments provided when creating validator';
const requireArgument = (value, type) => {
  if (isEmpty(value) || typeof value !== type) {
    throw new Error(requiredArgumentErrorMessage);
  }
};

const ALPHA_NUMERIC_PATTERN = /^[a-z0-9 ]*$/i;
const invalidAlphaNumericMessage = i18n.t('Please provide an alpha-numeric value');

const alphaNumeric = value => isEmpty(value) || isString(value) && ALPHA_NUMERIC_PATTERN.test(value) ? undefined : invalidAlphaNumericMessage;

const invalidBooleanMessage = i18n.t('Please provide a boolean value');

const boolean = value => isEmpty(value) || typeof value === 'boolean' ? undefined : invalidBooleanMessage;

const composeValidators = (...validators) => {
  return (...args) => {
    return validators.reduce((error, validator) => error || validator(...args), undefined);
  };
};

const createCharacterLengthRange = (lowerBound, upperBound, customMessage) => {
  requireArgument(lowerBound, 'number');
  requireArgument(upperBound, 'number');
  const errorMessage = customMessage || i18n.t('Please enter between {{lowerBound}} and {{upperBound}} characters', {
    lowerBound,
    upperBound
  });
  return value => isEmpty(value) || isString(value) && isInRange(lowerBound, upperBound, value.length) ? undefined : errorMessage;
};

const createEqualTo = (key, description) => {
  requireArgument(key, 'string');
  const errorMessage = i18n.t('Please make sure the value of this input matches the value in "{{otherField}}".', {
    otherField: description || key
  });
  return (value, allValues) => isEmpty(value) || value === allValues[key] ? undefined : errorMessage;
};

const createMaxCharacterLength = upperBound => createCharacterLengthRange(0, upperBound, i18n.t('Please enter a maximum of {{upperBound}} characters', {
  upperBound
}));

const createNumberRange = (lowerBound, upperBound, customMessage) => {
  requireArgument(lowerBound, 'number');
  requireArgument(upperBound, 'number');
  const errorMessage = customMessage || i18n.t('Number cannot be less than {{lowerBound}} or more than {{upperBound}}', {
    lowerBound,
    upperBound
  });
  return value => isEmpty(value) || isNumeric(value) && isInRange(lowerBound, upperBound, toNumber(value)) ? undefined : errorMessage;
};

const createMaxNumber = upperBound => createNumberRange(-Infinity, upperBound, i18n.t('Please enter a number with a maximum of {{upperBound}}', {
  upperBound
}));

const createMinCharacterLength = lowerBound => createCharacterLengthRange(lowerBound, Infinity, i18n.t('Please enter at least {{lowerBound}} characters', {
  lowerBound
}));

const createMinNumber = lowerBound => createNumberRange(lowerBound, Infinity, i18n.t('Please enter a number of at least {{lowerBound}}', {
  lowerBound
}));

const invalidPatternMessage = 'The first argument passed to createPattern was not a valid regex';

const createPattern = (pattern, message) => {
  if (!(pattern instanceof RegExp)) {
    throw new Error(invalidPatternMessage);
  }

  return value => isEmpty(value) || isString(value) && pattern.test(value) ? undefined : message || i18n.t('Please make sure the value of this input matches the pattern {{patternString}}.', {
    patternString: pattern.toString()
  });
};

const LOWER_CASE_PATTERN = /^(?=.*[a-z]).+$/;
const UPPER_CASE_PATTERN = /^(?=.*[A-Z]).+$/;
const DIGIT_PATTERN = /^(?=.*[0-9]).+$/; // Using this regex to match all non-alphanumeric characters to match server-side implementation
// https://github.com/dhis2/dhis2-core/blob/master/dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/user/SpecialCharacterValidationRule.java#L39

const SPECIAL_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;
const notString = i18n.t('Password should be a string');
const tooShort = i18n.t('Password should be at least 8 characters long');
const tooLong = i18n.t('Password should be no longer than 34 characters');
const noLowerCase = i18n.t('Password should contain at least one lowercase letter');
const noUpperCase = i18n.t('Password should contain at least one UPPERCASE letter');
const noNumber = i18n.t('Password should contain at least one number');
const noSpecialCharacter = i18n.t('Password should have at least one special character');
/**
 * Tests if a given password is compliant with the password restrictions.
 * This function checks all restrictions below, but returns when the first violation was found:
 * - At least 8 characters
 * - No more than 34 characters
 * - Contains at least 1 lowercase character
 * - Contains at least 1 UPPERCASE character
 * - Contains at least 1 number
 * - Contains at least 1 special character
 */

const dhis2Password = value => {
  if (isEmpty(value)) {
    return undefined;
  }

  if (!isString(value)) {
    return notString;
  }

  if (value.length < 8) {
    return tooShort;
  }

  if (value.length > 35) {
    return tooLong;
  }

  if (!LOWER_CASE_PATTERN.test(value)) {
    return noLowerCase;
  }

  if (!UPPER_CASE_PATTERN.test(value)) {
    return noUpperCase;
  }

  if (!DIGIT_PATTERN.test(value)) {
    return noNumber;
  }

  if (!SPECIAL_CHARACTER_PATTERN.test(value)) {
    return noSpecialCharacter;
  }

  return undefined;
};

const invalidUsernameMessage = i18n.t('Please provide a username between 1 and 255 characters');

const dhis2Username = value => isEmpty(value) || isString(value) && value.length >= 1 && value.length <= 255 ? undefined : invalidUsernameMessage;

/*
 * Email validation is complicated business. There is no perfect regex,
 * instead we have to make a trade-off between complexity, correctness,
 * and the risk of producing false negatives. This article
 * https://www.regular-expressions.info/email.html offers a good overview.
 * It recommends to use a very simple regex when having to validate many
 * records, but for validating an individual email address a more complex
 * regex may be used.
 *
 * The pattern below is taken from the "The Official Standard: RFC 5322"
 * section of the article and is described as:
 * "[..] a more practical implementation of RFC 5322 [..] that will still
 * match 99.99% of all email addresses in actual use today"
 *
 * const EMAIL_ADDRESS_PATTERN = /[a-z0-9!#$%&'*+/=?^_‘{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_‘{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/i
 *
 * However, this regex produces a few false negatives and quite a lot
 * of false positives.
 *
 * Another regex, found in this stackoverflow answer below resulted in a better
 * overall picture in terms of false negatives and positives, so I settled on that one:
 * https://stackoverflow.com/questions/46155/how-to-validate-an-email-address-in-javascript/46181#46181
 */

const EMAIL_ADDRESS_PATTERN = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/i;
const invalidEmailMessage = i18n.t('Please provide a valid email address');

const email = value => isEmpty(value) || isString(value) && EMAIL_ADDRESS_PATTERN.test(value) ? undefined : invalidEmailMessage;

const hasValueMessage = i18n.t('Please provide a value');

const hasValue = value => isEmpty(value) ? hasValueMessage : undefined;

const invalidIntegerMessage = i18n.t('Please provide a round number without decimals');

const integer = value => isEmpty(value) || isNumeric(value) && isInteger(toNumber(value)) ? undefined : invalidIntegerMessage;

/*
 * There were some problems with the server side implementation
 * of how international phone numbers are validated, and the
 * server side implementation will likely be removed, see:
 * https://jira.dhis2.org/browse/DHIS2-8040
 *
 * So, rather than aligning with the server-side implementation
 * this validator implements the E.164 numbering plan, see:
 * https://www.cm.com/blog/how-to-format-international-telephone-numbers/
 *
 * SPECS
 * Here's how the E.164 numbering plan works:
 * - A telephone number can have a maximum of 15 digits
 * - The first part of the telephone number is the country code (one to three digits)
 * - The second part is the national destination code (NDC)
 * - The last part is the subscriber number (SN)
 * - The NDC and SN together are collectively called the national (significant) number
 *
 * IMPLEMENTATION ADVICE
 * Two important things to note: First of all, in the international E.164 notation a
 * leading ‘0’ is removed. The UK mobile phone number ‘07911 123456’ in international
 * format is ‘+44 7911 123456’, so without the first zero. Secondly in the E.164 notation
 * all spaces, dashes [‘-‘] and parentheses [ ‘(‘ and ‘)’] are removed, besides the
 * leading ‘+’ all characters should be numeric.
 */

const invalidInternationalPhoneNumberMessage = i18n.t('Please provide a valid international phone number.');

const internationalPhoneNumber = value => {
  // allow empty values
  if (isEmpty(value)) {
    return undefined;
  } // value must be a string


  if (!isString(value)) {
    return invalidInternationalPhoneNumberMessage;
  }

  const cleanedValue = value // strip all hyphens, dots, spaces
  .replace(/[-. )(]/g, '') // trim leading zeroes and plus signs
  .replace(/^[0+]+/, '');
  return isNumeric(cleanedValue) && cleanedValue.length <= 15 ? undefined : invalidInternationalPhoneNumberMessage;
};

const invalidNumberMessage = i18n.t('Please provide a number');

const number = value => isEmpty(value) || isNumeric(value) ? undefined : invalidNumberMessage;

const invalidStringMessage = i18n.t('Please provide a string');

const string = value => isEmpty(value) || isString(value) ? undefined : invalidStringMessage;

const URL_PATTERN = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
const invalidUrlMessage = i18n.t('Please provide a valid url');

const url = value => isEmpty(value) || isString(value) && URL_PATTERN.test(value) ? undefined : invalidUrlMessage;

exports.ReactFinalForm = reactFinalForm;
exports.FinalForm = finalForm;
exports.CheckboxFieldFF = CheckboxFieldFF;
exports.FieldGroupFF = FieldGroupFF;
exports.FileInputFieldFF = FileInputFieldFF;
exports.InputFieldFF = InputFieldFF;
exports.MultiSelectFieldFF = MultiSelectFieldFF;
exports.RadioFieldFF = RadioFieldFF;
exports.SingleSelectFieldFF = SingleSelectFieldFF;
exports.SwitchFieldFF = SwitchFieldFF;
exports.TextAreaFieldFF = TextAreaFieldFF;
exports.alphaNumeric = alphaNumeric;
exports.arrayWithIdObjects = arrayWithIdObjects;
exports.boolean = boolean;
exports.composeValidators = composeValidators;
exports.createCharacterLengthRange = createCharacterLengthRange;
exports.createEqualTo = createEqualTo;
exports.createMaxCharacterLength = createMaxCharacterLength;
exports.createMaxNumber = createMaxNumber;
exports.createMinCharacterLength = createMinCharacterLength;
exports.createMinNumber = createMinNumber;
exports.createNumberRange = createNumberRange;
exports.createPattern = createPattern;
exports.dhis2Password = dhis2Password;
exports.dhis2Username = dhis2Username;
exports.email = email;
exports.hasValue = hasValue;
exports.integer = integer;
exports.internationalPhoneNumber = internationalPhoneNumber;
exports.number = number;
exports.string = string;
exports.url = url;
//# sourceMappingURL=lib.js.map
